variables:
  custom_domain:
    type: string
    description: "The ID of the 'CustomDomain', which is the domain name you'd like to use with Firebase Hosting."
  site_id:
    type: string
    description: "The ID of the site in which to create this custom domain association."
  cert_preference:
    type: string
    description: "A field that lets you specify which SSL certificate type Hosting creates for your domain name. Spark plan 'CustomDomain's only have access to the 'GROUPED' cert type, while Blaze plan can select any option. Possible values: [\"GROUPED\", \"PROJECT_GROUPED\", \"DEDICATED\"]"
    default: null
  id:
    type: string
    description: "Optional property for HostingCustomDomain"
    default: null
  project:
    type: string
    description: "Optional property for HostingCustomDomain"
    default: null
  redirect_target:
    type: string
    description: "A domain name that this CustomDomain should direct traffic towards. If specified, Hosting will respond to requests against this CustomDomain with an HTTP 301 code, and route traffic to the specified 'redirect_target' instead."
    default: null
  wait_dns_verification:
    type: boolean
    description: "If true, Terraform will wait for DNS records to be fully resolved on the 'CustomDomain'. If false, Terraform will not wait for DNS records on the 'CustomDomain'. Any issues in the 'CustomDomain' will be returned and stored in the Terraform state."
    default: null
  timeouts:
    type: list
    description: "Nested block: timeouts"
    default: []

resources:
  main:
    type: gcp:firebase:HostingCustomDomain
    properties:
      custom_domain: ${var.custom_domain}
      site_id: ${var.site_id}
      cert_preference: ${var.cert_preference}
      id: ${var.id}
      project: ${var.project}
      redirect_target: ${var.redirect_target}
      wait_dns_verification: ${var.wait_dns_verification}
      dynamic:
        timeouts:
          for_each: ${var.timeouts}
          content:
            create: ${each.value.create}
            delete: ${each.value.delete}
            update: ${each.value.update}
