variables:
  acl_id:
    type: string
    description: "The ID to use for the acl, which will become the final component of the acl's name. The structure of 'aclId' defines the Resource Pattern (resource_type, resource_name, pattern_type) of the acl. 'aclId' is structured like one of the following: For acls on the cluster: 'cluster' For acls on a single resource within the cluster: 'topic/{resource_name}' 'consumerGroup/{resource_name}' 'transactionalId/{resource_name}' For acls on all resources that match a prefix: 'topicPrefixed/{resource_name}' 'consumerGroupPrefixed/{resource_name}' 'transactionalIdPrefixed/{resource_name}' For acls on all resources of a given type (i.e. the wildcard literal '*''): 'allTopics' (represents 'topic/*') 'allConsumerGroups' (represents 'consumerGroup/*') 'allTransactionalIds' (represents 'transactionalId/*')."
  cluster:
    type: string
    description: "The cluster name."
  location:
    type: string
    description: "ID of the location of the Kafka resource. See https://cloud.google.com/managed-kafka/docs/locations for a list of supported locations."
  id:
    type: string
    description: "Optional property for KafkaAcl"
    default: null
  project:
    type: string
    description: "Optional property for KafkaAcl"
    default: null
  acl_entries:
    type: list
    description: "Nested block: acl_entries"
    default: []
  timeouts:
    type: list
    description: "Nested block: timeouts"
    default: []

resources:
  main:
    type: gcp:managed:KafkaAcl
    properties:
      acl_id: ${var.acl_id}
      cluster: ${var.cluster}
      location: ${var.location}
      id: ${var.id}
      project: ${var.project}
      dynamic:
        acl_entries:
          for_each: ${var.acl_entries}
          content:
            host: ${each.value.host}
            operation: ${each.value.operation}
            permission_type: ${each.value.permission_type}
            principal: ${each.value.principal}
        timeouts:
          for_each: ${var.timeouts}
          content:
            create: ${each.value.create}
            delete: ${each.value.delete}
            update: ${each.value.update}
