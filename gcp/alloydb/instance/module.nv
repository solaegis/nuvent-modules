variables:
  cluster:
    type: string
    description: "Identifies the alloydb cluster. Must be in the format 'projects/{project}/locations/{location}/clusters/{cluster_id}'"
  instance_id:
    type: string
    description: "The ID of the alloydb instance."
  instance_type:
    type: string
    description: "The type of the instance. If the instance type is READ_POOL, provide the associated PRIMARY/SECONDARY instance in the 'depends_on' meta-data attribute. If the instance type is SECONDARY, point to the cluster_type of the associated secondary cluster instead of mentioning SECONDARY. Example: {instance_type = google_alloydb_cluster.<secondary_cluster_name>.cluster_type} instead of {instance_type = SECONDARY} If the instance type is SECONDARY, the terraform delete instance operation does not delete the secondary instance but abandons it instead. Use deletion_policy = \"FORCE\" in the associated secondary cluster and delete the cluster forcefully to delete the secondary cluster as well its associated secondary instance. Users can undo the delete secondary instance action by importing the deleted secondary instance by calling terraform import. Possible values: [\"PRIMARY\", \"READ_POOL\", \"SECONDARY\"]"
  activation_policy:
    type: string
    description: "'Specifies whether an instance needs to spin up. Once the instance is active, the activation policy can be updated to the 'NEVER' to stop the instance. Likewise, the activation policy can be updated to 'ALWAYS' to start the instance. There are restrictions around when an instance can/cannot be activated (for example, a read pool instance should be stopped before stopping primary etc.). Please refer to the API documentation for more details. Possible values are: 'ACTIVATION_POLICY_UNSPECIFIED', 'ALWAYS', 'NEVER'.' Possible values: [\"ACTIVATION_POLICY_UNSPECIFIED\", \"ALWAYS\", \"NEVER\"]"
    default: null
  annotations:
    type: object
    description: "Annotations to allow client tools to store small amount of arbitrary data. This is distinct from labels.  **Note**: This field is non-authoritative, and will only manage the annotations present in your configuration. Please refer to the field 'effective_annotations' for all of the annotations present on the resource."
    default: null
  availability_type:
    type: string
    description: "'Availability type of an Instance. Defaults to REGIONAL for both primary and read instances. Note that primary and read instances can have different availability types. Primary instances can be either ZONAL or REGIONAL. Read Pool instances can also be either ZONAL or REGIONAL. Read pools of size 1 can only have zonal availability. Read pools with a node count of 2 or more can have regional availability (nodes are present in 2 or more zones in a region). Possible values are: 'AVAILABILITY_TYPE_UNSPECIFIED', 'ZONAL', 'REGIONAL'.' Possible values: [\"AVAILABILITY_TYPE_UNSPECIFIED\", \"ZONAL\", \"REGIONAL\"]"
    default: null
  database_flags:
    type: object
    description: "Database flags. Set at instance level. * They are copied from primary instance on read instance creation. * Read instances can set new or override existing flags that are relevant for reads, e.g. for enabling columnar cache on a read instance. Flags set on read instance may or may not be present on primary."
    default: null
  display_name:
    type: string
    description: "User-settable and human-readable display name for the Instance."
    default: null
  gce_zone:
    type: string
    description: "The Compute Engine zone that the instance should serve from, per https://cloud.google.com/compute/docs/regions-zones This can ONLY be specified for ZONAL instances. If present for a REGIONAL instance, an error will be thrown. If this is absent for a ZONAL instance, instance is created in a random zone with available capacity."
    default: null
  id:
    type: string
    description: "Optional property for Instance"
    default: null
  labels:
    type: object
    description: "User-defined labels for the alloydb instance.  **Note**: This field is non-authoritative, and will only manage the labels present in your configuration. Please refer to the field 'effective_labels' for all of the labels present on the resource."
    default: null
  client_connection_config:
    type: list
    description: "Nested block: client_connection_config"
    default: []
  connection_pool_config:
    type: list
    description: "Nested block: connection_pool_config"
    default: []
  machine_config:
    type: list
    description: "Nested block: machine_config"
    default: []
  network_config:
    type: list
    description: "Nested block: network_config"
    default: []
  observability_config:
    type: list
    description: "Nested block: observability_config"
    default: []
  psc_instance_config:
    type: list
    description: "Nested block: psc_instance_config"
    default: []
  query_insights_config:
    type: list
    description: "Nested block: query_insights_config"
    default: []
  read_pool_config:
    type: list
    description: "Nested block: read_pool_config"
    default: []
  timeouts:
    type: list
    description: "Nested block: timeouts"
    default: []

resources:
  main:
    type: gcp:alloydb:Instance
    properties:
      cluster: ${var.cluster}
      instance_id: ${var.instance_id}
      instance_type: ${var.instance_type}
      activation_policy: ${var.activation_policy}
      annotations: ${var.annotations}
      availability_type: ${var.availability_type}
      database_flags: ${var.database_flags}
      display_name: ${var.display_name}
      gce_zone: ${var.gce_zone}
      id: ${var.id}
      labels: ${var.labels}
      dynamic:
        client_connection_config:
          for_each: ${var.client_connection_config}
          content:
            require_connectors: ${each.value.require_connectors}
            ssl_config: ${each.value.ssl_config}
        connection_pool_config:
          for_each: ${var.connection_pool_config}
          content:
            enabled: ${each.value.enabled}
            flags: ${each.value.flags}
            pooler_count: ${each.value.pooler_count}
        machine_config:
          for_each: ${var.machine_config}
          content:
            cpu_count: ${each.value.cpu_count}
            machine_type: ${each.value.machine_type}
        network_config:
          for_each: ${var.network_config}
          content:
            allocated_ip_range_override: ${each.value.allocated_ip_range_override}
            enable_outbound_public_ip: ${each.value.enable_outbound_public_ip}
            enable_public_ip: ${each.value.enable_public_ip}
            authorized_external_networks: ${each.value.authorized_external_networks}
        observability_config:
          for_each: ${var.observability_config}
          content:
            assistive_experiences_enabled: ${each.value.assistive_experiences_enabled}
            enabled: ${each.value.enabled}
            max_query_string_length: ${each.value.max_query_string_length}
            preserve_comments: ${each.value.preserve_comments}
            query_plans_per_minute: ${each.value.query_plans_per_minute}
            record_application_tags: ${each.value.record_application_tags}
            track_active_queries: ${each.value.track_active_queries}
            track_wait_event_types: ${each.value.track_wait_event_types}
            track_wait_events: ${each.value.track_wait_events}
        psc_instance_config:
          for_each: ${var.psc_instance_config}
          content:
            allowed_consumer_projects: ${each.value.allowed_consumer_projects}
            psc_dns_name: ${each.value.psc_dns_name}
            service_attachment_link: ${each.value.service_attachment_link}
            psc_auto_connections: ${each.value.psc_auto_connections}
            psc_interface_configs: ${each.value.psc_interface_configs}
        query_insights_config:
          for_each: ${var.query_insights_config}
          content:
            query_plans_per_minute: ${each.value.query_plans_per_minute}
            query_string_length: ${each.value.query_string_length}
            record_application_tags: ${each.value.record_application_tags}
            record_client_address: ${each.value.record_client_address}
        read_pool_config:
          for_each: ${var.read_pool_config}
          content:
            node_count: ${each.value.node_count}
        timeouts:
          for_each: ${var.timeouts}
          content:
            create: ${each.value.create}
            delete: ${each.value.delete}
            update: ${each.value.update}
